// @title           Anki Backend API
// @version         1.0
// @description     REST API for Anki Backend system. This API provides endpoints for managing decks, notes, cards, and study sessions.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.email  support@anki.example.com

// @license.name  MIT
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /

package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/labstack/echo/v4"
	"github.com/labstack/echo/v4/middleware"
	echoSwagger "github.com/swaggo/echo-swagger"

	_ "github.com/felipesantos/anki-backend/docs" // Swagger docs (generated by swag init)
	"github.com/felipesantos/anki-backend/app/api/middlewares"
	"github.com/felipesantos/anki-backend/app/api/routes"
	"github.com/felipesantos/anki-backend/config"
	"github.com/felipesantos/anki-backend/core/services/health"
	"github.com/felipesantos/anki-backend/infra/postgres"
	"github.com/felipesantos/anki-backend/infra/redis"
	"github.com/felipesantos/anki-backend/pkg/logger"
	// Uncomment to enable automatic migrations on startup
	"github.com/felipesantos/anki-backend/pkg/migrate"
)

func main() {
	// 1. Load configuration
	cfg, err := config.Load()
	if err != nil {
		// If unable to load config, use default logger
		logger.InitLogger("INFO", "development")
		log := logger.GetLogger()
		log.Error("Failed to load configuration", "error", err)
		os.Exit(1)
	}

	// 2. Initialize logger with configuration
	logger.InitLogger(cfg.Logger.Level, cfg.Logger.Environment)
	log := logger.GetLogger()

	log.Info("Application starting",
		"environment", cfg.Logger.Environment,
		"log_level", cfg.Logger.Level,
	)

	// 3. Initialize database connection
	db, err := postgres.NewPostgresRepository(cfg.Database, log)
	if err != nil {
		log.Error("Failed to initialize database connection", "error", err)
		os.Exit(1)
	}

	// Optional: Run migrations on startup
	// Uncomment the lines below to run migrations automatically
	// In production, it's usually better to run migrations manually via CI/CD
	//
	if err := migrate.RunMigrations(cfg.Database, log); err != nil {
	    log.Error("Failed to run migrations", "error", err)
	    os.Exit(1)
	}

	// 4. Initialize Redis connection
	rdb, err := redis.NewRedisRepository(cfg.Redis, log)
	if err != nil {
		log.Error("Failed to initialize Redis connection", "error", err)
		// Redis is optional for some applications, but we'll treat it as an error
		// If optional, you can comment out os.Exit(1)
		os.Exit(1)
	}

	// 5. Initialize Health Service
	healthService := health.NewHealthService(db, rdb)

	// 6. Initialize HTTP server (Echo)
	e := echo.New()
	e.HideBanner = true

	// Configure custom error handler (must be set before routes)
	e.HTTPErrorHandler = middlewares.CustomHTTPErrorHandler

	// Middleware
	e.Use(middleware.Recover())
	e.Use(middlewares.CORSMiddleware(cfg.CORS)) // CORS should be early in the chain to handle preflight requests
	e.Use(middlewares.RequestIDMiddleware())
	
	// Rate limiting middleware (after logging would go, but we'll add logging middleware later)
	// Rate limiting should come after RequestID to have request IDs in logs
	e.Use(middlewares.RateLimitingMiddleware(cfg.RateLimit, rdb.Client))

	// Swagger documentation endpoint
	e.GET("/swagger/*", echoSwagger.WrapHandler)

	// Test endpoint for rate limiting (remove in production if not needed)
	e.GET("/api/test", func(c echo.Context) error {
		return c.JSON(http.StatusOK, map[string]interface{}{
			"message": "Test endpoint for rate limiting",
			"timestamp": time.Now().Unix(),
		})
	})

	// Register routes
	routes.RegisterHealthRoutes(e, healthService)

	// Start HTTP server
	serverAddr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)
	srv := &http.Server{
		Addr:         serverAddr,
		Handler:      e,
		ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
		IdleTimeout:  time.Duration(cfg.Server.IdleTimeout) * time.Second,
	}

	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// Start server in goroutine
	serverErrChan := make(chan error, 1)
	go func() {
		log.Info("Starting HTTP server",
			"address", serverAddr,
			"read_timeout", cfg.Server.ReadTimeout,
			"write_timeout", cfg.Server.WriteTimeout,
		)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error("HTTP server error", "error", err)
			serverErrChan <- err
			cancel()
		}
	}()

	// Give the server a moment to start and check for immediate errors
	select {
	case err := <-serverErrChan:
		if err != nil {
			log.Error("Failed to start HTTP server", "error", err)
			os.Exit(1)
		}
	case <-time.After(100 * time.Millisecond):
		// Server started successfully (no immediate error)
		log.Info("HTTP server started successfully", "address", serverAddr)
	}

	// Graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

	go func() {
		<-sigChan
		log.Info("Shutdown signal received, shutting down gracefully...")
		cancel()
	}()

	// Wait for context cancellation
	<-ctx.Done()

	// Graceful shutdown of HTTP server
	log.Info("Shutting down HTTP server...")
	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer shutdownCancel()

	if err := srv.Shutdown(shutdownCtx); err != nil {
		log.Error("Error shutting down HTTP server", "error", err)
	} else {
		log.Info("HTTP server shut down successfully")
	}

	// Close Redis connection gracefully
	log.Info("Closing Redis connection...")
	if err := rdb.Close(); err != nil {
		log.Error("Error closing Redis connection", "error", err)
	} else {
		log.Info("Redis connection closed successfully")
	}

	// Close database connection gracefully
	log.Info("Closing database connection...")
	if err := db.Close(); err != nil {
		log.Error("Error closing database connection", "error", err)
	} else {
		log.Info("Database connection closed successfully")
	}

	time.Sleep(1 * time.Second)
	log.Info("Server stopped")
}
