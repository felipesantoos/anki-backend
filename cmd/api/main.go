// @title           Anki Backend API
// @version         1.0
// @description     REST API for Anki Backend system. This API provides endpoints for managing decks, notes, cards, and study sessions.
// @termsOfService  http://swagger.io/terms/

// @contact.name   API Support
// @contact.email  support@anki.example.com

// @license.name  MIT
// @license.url   http://www.apache.org/licenses/LICENSE-2.0.html

// @host      localhost:8080
// @BasePath  /

// @securityDefinitions.apikey BearerAuth
// @in header
// @name Authorization
// @description Type "Bearer" followed by a space and JWT token. Example: "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

package main

import (
	"context"
	"fmt"
	"log/slog"
	"net/http"
	"os"
	"os/signal"
	"strings"
	"syscall"
	"time"

	"github.com/labstack/echo/v4"

	_ "github.com/felipesantos/anki-backend/docs" // Swagger docs (generated by swag init)
	"github.com/felipesantos/anki-backend/app/api/routes"
	"github.com/felipesantos/anki-backend/config"
	"github.com/felipesantos/anki-backend/dicontainer"
	domainEvents "github.com/felipesantos/anki-backend/core/domain/events"
	"github.com/felipesantos/anki-backend/core/services/events"
	storageService "github.com/felipesantos/anki-backend/core/services/storage"
	tracingService "github.com/felipesantos/anki-backend/core/services/tracing"
	"github.com/felipesantos/anki-backend/core/interfaces/secondary"
	eventHandlers "github.com/felipesantos/anki-backend/infra/events/handlers"
	infraEvents "github.com/felipesantos/anki-backend/infra/events"
	"github.com/felipesantos/anki-backend/infra/jobs/handlers"
	infraJobs "github.com/felipesantos/anki-backend/infra/jobs"
	"github.com/felipesantos/anki-backend/infra/postgres"
	"github.com/felipesantos/anki-backend/infra/redis"
	"github.com/felipesantos/anki-backend/pkg/jwt"
	"github.com/felipesantos/anki-backend/pkg/logger"
	"github.com/felipesantos/anki-backend/pkg/migrate"
)

func main() {
	cfg := initConfig()
	log := initLogger(cfg)
	tracingSvc := initTracing(cfg, log)
	db := initDatabase(cfg, log)
	rdb := initRedis(cfg, log)
	jwtSvc := initJWT(cfg, log)
	eventBus, eventService := initEvents(cfg, log)

	// 8. Initialize DI Package
	dicontainer.Init(db, rdb, eventBus, jwtSvc, cfg, log)

	// 9. Initialize Jobs and Storage
	workerPool, scheduler := initJobs(cfg, rdb, log)

	storageRepo, _ := storageService.NewStorageRepository(cfg.Storage, log)
	_ = storageService.NewStorageService(storageRepo, log)

	e := setupEcho(cfg, rdb, jwtSvc, eventService)

	runServer(cfg, e, log, workerPool, scheduler, eventBus, rdb, db, tracingSvc)
}

func initConfig() *config.Config {
	cfg, err := config.Load()
	if err != nil {
		logger.InitLogger("INFO", "development")
		log := logger.GetLogger()
		if validationErr, ok := err.(*config.ValidationError); ok {
			log.Error("Configuration validation failed", "error", validationErr.Error())
			fmt.Fprintf(os.Stderr, "\n❌ Configuration Error: %s\n\n", validationErr.Error())
			os.Exit(1)
		}
		if requiredErr, ok := err.(*config.RequiredEnvError); ok {
			log.Error("Missing required environment variables", "environment", requiredErr.Environment, "variables", requiredErr.Variables, "error", requiredErr.Error())
			fmt.Fprintf(os.Stderr, "\n❌ Missing Required Environment Variables:\n")
			fmt.Fprintf(os.Stderr, "   Environment: %s\n", requiredErr.Environment)
			fmt.Fprintf(os.Stderr, "   Missing variables: %s\n\n", strings.Join(requiredErr.Variables, ", "))
			os.Exit(1)
		}
		log.Error("Failed to load configuration", "error", err)
		fmt.Fprintf(os.Stderr, "\n❌ Failed to load configuration: %v\n\n", err)
		os.Exit(1)
	}
	return cfg
	}

func initLogger(cfg *config.Config) *slog.Logger {
	logger.InitLogger(cfg.Logger.Level, cfg.Logger.Environment)
	log := logger.GetLogger()
	log.Info("Application starting", "environment", cfg.Logger.Environment, "log_level", cfg.Logger.Level)
	return log
}

func initTracing(cfg *config.Config, log *slog.Logger) *tracingService.TracingService {
	if !cfg.Tracing.Enabled {
		return nil
	}
	tracingSvc, err := tracingService.NewTracingService(cfg.Tracing)
	if err != nil {
		log.Error("Failed to initialize tracing service", "error", err)
		os.Exit(1)
	}
	log.Info("Tracing system initialized")
	return tracingSvc
}

func initDatabase(cfg *config.Config, log *slog.Logger) *postgres.PostgresRepository {
	db, err := postgres.NewPostgresRepository(cfg.Database, log)
	if err != nil {
		log.Error("Failed to initialize database connection", "error", err)
		os.Exit(1)
	}
	if err := migrate.RunMigrations(cfg.Database, log); err != nil {
		log.Error("Failed to run migrations", "error", err)
		os.Exit(1)
	}
	return db
}

func initRedis(cfg *config.Config, log *slog.Logger) *redis.RedisRepository {
	rdb, err := redis.NewRedisRepository(cfg.Redis, log)
	if err != nil {
		log.Error("Failed to initialize Redis connection", "error", err)
		os.Exit(1)
	}
	return rdb
}

func initJWT(cfg *config.Config, log *slog.Logger) *jwt.JWTService {
	jwtSvc, err := jwt.NewJWTService(cfg.JWT)
	if err != nil {
		log.Error("Failed to initialize JWT service", "error", err)
		os.Exit(1)
	}
	return jwtSvc
}

func initEvents(cfg *config.Config, log *slog.Logger) (secondary.IEventBus, *events.EventService) {
	var eventService *events.EventService
	var eventBus secondary.IEventBus
	if cfg.Events.Enabled {
		eventBus = infraEvents.NewInMemoryEventBus(cfg.Events.WorkerCount, cfg.Events.QueueSize, log)
		eventService = events.NewEventService(eventBus)
		if err := eventBus.Start(); err != nil {
			log.Error("Failed to start event bus", "error", err)
			os.Exit(1)
		}
		log.Info("Events system initialized")
	} else {
		eventBus = infraEvents.NewInMemoryEventBus(1, 10, log)
		if err := eventBus.Start(); err != nil {
			log.Error("Failed to start minimal event bus", "error", err)
			os.Exit(1)
		}
	}
	return eventBus, eventService
}

func initJobs(cfg *config.Config, rdb *redis.RedisRepository, log *slog.Logger) (*infraJobs.WorkerPool, *infraJobs.Scheduler) {
	if !cfg.Jobs.Enabled {
		return nil, nil
	}
	jobQueue := infraJobs.NewRedisQueue(rdb.Client, cfg.Jobs.RedisQueueKey)
	jobRegistry := infraJobs.NewJobRegistry()
	jobRegistry.Register(handlers.NewExampleHandler("example_job"))
	workerPool := infraJobs.NewWorkerPool(cfg.Jobs.WorkerCount, jobQueue, jobRegistry, log, cfg.Jobs.MaxRetries, cfg.Jobs.RetryDelaySeconds)
	scheduler := infraJobs.NewScheduler(jobQueue, log)
	workerPool.Start()
	scheduler.Start()
	return workerPool, scheduler
}

func setupEcho(cfg *config.Config, rdb *redis.RedisRepository, jwtSvc *jwt.JWTService, eventService *events.EventService) *echo.Echo {
	e := echo.New()

	// Initialize router with middlewares and routes
	router := routes.NewRouter(e, cfg, jwtSvc, rdb)
	router.Init()

	if cfg.Events.Enabled && eventService != nil {
		eventService.Subscribe(domainEvents.UserRegisteredEventType, eventHandlers.NewEmailVerificationHandler(dicontainer.GetEmailService()))
	}

	return e
}

func runServer(cfg *config.Config, e *echo.Echo, log *slog.Logger, workerPool *infraJobs.WorkerPool, scheduler *infraJobs.Scheduler, eventBus secondary.IEventBus, rdb *redis.RedisRepository, db *postgres.PostgresRepository, tracingSvc *tracingService.TracingService) {
	serverAddr := fmt.Sprintf("%s:%s", cfg.Server.Host, cfg.Server.Port)
	srv := &http.Server{
		Addr:         serverAddr,
		Handler:      e,
		ReadTimeout:  time.Duration(cfg.Server.ReadTimeout) * time.Second,
		WriteTimeout: time.Duration(cfg.Server.WriteTimeout) * time.Second,
		IdleTimeout:  time.Duration(cfg.Server.IdleTimeout) * time.Second,
	}

	stop := make(chan bool, 1)
	go func() {
		log.Info("Starting HTTP server", "address", serverAddr)
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error("HTTP server error", "error", err)
			stop <- true
		}
	}()

	// Graceful shutdown
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	select {
	case <-sigChan:
		log.Info("Shutting down gracefully...")
	case <-stop:
		log.Info("Server stopped unexpectedly")
	}

	shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), time.Duration(cfg.Server.ShutdownTimeout)*time.Second)
	defer shutdownCancel()

	if workerPool != nil {
		workerPool.Stop()
	}
	if scheduler != nil {
		scheduler.Stop()
	}
	if eventBus != nil {
		eventBus.Stop()
	}
	srv.Shutdown(shutdownCtx)
	rdb.Close()
	db.Close()
	if tracingSvc != nil {
		tracingSvc.Shutdown(context.Background())
	}

	log.Info("Server stopped")
}
